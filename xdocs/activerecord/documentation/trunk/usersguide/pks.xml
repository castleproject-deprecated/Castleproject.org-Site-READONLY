<?xml version="1.0"?>
<document order="5">
  <properties>
    <title>Primary key mapping</title>
  </properties>

  <body>

<intro>
<p>
Regular <i>ActiveRecord types</i> must have a primary key, a key that uniquely indentifies any row
in a table. Single surrogate keys are favouvered over composite keys, but both are supported. 
When having control over the database schema, adding a surrogate primary key to the tables is the
recommended way of implementing primary keys.
</p>
</intro>

<section id="SinglePK">
	<title>Single Primary Key</title>

	<p>
	A single primary key is a column used as a row identifier. If it has no business meaning and
	can be choosen freely among unused values, the key is called a <strong>surrogate primary key.
	</strong> Primary keys can be assigned by the using code, auto generated by the database or 
	by ActiveRecord using	one of the strategies to generated non duplicate values. 
	</p>
		
	<p>
	To declare a primary key in a class a property to hold it must be created and decorated with 
	the <tt>PrimaryKeyAttribute</tt>.	This attribute holds information for mapping the primary
	key column. Most importantly, it determines the generation strategy which defaults to 
	native, using an auto generation method supported by the used database. 
	The following table script shows a simple entity:
	</p>
	
	<pre format="tsql">
CREATE TABLE Entity (
	[id] [int] IDENTITY (1, 1) NOT NULL
	-- payload ommitted for clarity
) ON [PRIMARY]
</pre>
	
	<p>
	This table would be easily mapped to an ActiveRecord class:
	</p>
	
	<pre format="cs"><![CDATA[
using Castle.ActiveRecord;

[ActiveRecord]
public class Entity : ActiveRecordBase<Entity>
{
	private int id;
	
	[PrimaryKey(PrimaryKeyType.Native)]
	private int Id
	{
		get { return id; }
		set { id = value; }
	}
	
	// payload ommitted for clarity
}]]></pre>

	<p>
	For this case, the <tt>PrimaryKeyType</tt> could be omitted as it will default
	to <tt>Native</tt> anyway. ActiveRecord will correctly <b>assume</b>
	that the column name is <tt>Id</tt>.	If the column had a different name, for example 
	<tt>EntityId</tt>, it must be explicitly specified:
	</p>

	<pre format="cs">
	private int id;
	
	[PrimaryKey(PrimaryKeyType.Native, "EntityId")]
	private int Id
	{
		get { return id; }
		set { id = value; }
	}</pre>
	
	<p>
	A setter is not needed for the primary key, but	ActiveRecord needs to set the value somehow.
	For example the key can be directly set by using the backing field. This requires that the
	<tt>Access</tt> is specified:
	</p>
	
	<pre format="cs">
	private int id;
	
	[PrimaryKey(Access=PropertyAccess.FieldCamelcase)]
	private int Id
	{
		get { return id; }
	}</pre>
	
	<section id="diffstrategies">
		<title>Key Generation strategies</title>

		<p>
		ActiveRecord supports all strategies implemented by NHibernate for creating primary keys.
		The possible strategies are listed below with a short explanation. For some more details please refer to <a href="http://stackoverflow.com/questions/575069/castle-activerecord-seeding-primary-key-value/575469#575469">this posting</a>.
		</p>

		<table class="commontable">
			<tr>
				<th>Name</th>
				<th>Enum Value</th>
				<th>Description</th>
			</tr>
			
			<tr>
				<td>Identity</td>
				<td><tt>PrimaryKeyType.Identity</tt></td>
				<td>
				Uses an identity column if available. Objects will be instantly inserted when saved.
				</td>
			</tr>
			<tr>
				<td>Sequence</td>
				<td><tt>PrimaryKeyType.Sequence</tt></td>
				<td>
				Uses sequences where supported by the database. Two database calls are necessary for saving an object.
				The sequence name can be specified with the <tt>sequence</tt>-parameter or the <tt>SequenceName</tt>-
				property.
				</td>
			</tr>
			<tr>
				<td>Hi/Lo</td>
				<td><tt>PrimaryKeyType.HiLo</tt></td>
				<td>
				Uses a Hi/Lo algorithm. Hi values are stored in a special database table. A hi value is fetched once and
				incremented locally. <tt>table</tt>, <tt>column</tt> and <tt>max_lo</tt> can be specified as parameters,
				with <tt>max_lo</tt> specifying the number of values locally incremented before fetching a new high value.
				</td>
			</tr>
			<tr>
				<td>Sequence Hi/Lo</td>
				<td><tt>PrimaryKeyType.SeqHiLo</tt></td>
				<td>
				Uses a Hi/Lo algorithm. The hi values are fetched from an Oracle-style sequence and
				incremented locally. Parameters are <tt>sequence</tt> and <tt>max_lo</tt>.
				</td>
			</tr>
			<tr>
				<td>UUID (hex representation)</td>
				<td><tt>PrimaryKeyType.UuidHex</tt></td>
				<td>
				This strategy uses a guid and converts it into a hex representation, creating a readable string, customized
				by format and separator specification. This allows to use guids on databases that do not support GUIDs.
				<tt>format</tt> and <tt>separator</tt> must be specified as parameters.
				</td>
			</tr>
			<tr>
				<td>UUID (compact representation)</td>
				<td><tt>PrimaryKeyType.UuidString</tt></td>
				<td>
				This strategy uses a guid and converts it into a byte-array, casting it into a string. It is written to
				the database as a <tt>CHAR(16)</tt>, using up less space than <tt>UuidHex</tt>, but creating unprintable
				representations.
				</td>
			</tr>
			<tr>
				<td>GUID</td>
				<td><tt>PrimaryKeyType.Guid</tt></td>
				<td>
				Uses GUIDs where supported by the database. 
				</td>
			</tr>
			<tr>
				<td>Combined GUID</td>
				<td><tt>PrimaryKeyType.GuidComb</tt></td>
				<td>
				Uses GUIDs where supported by the database. The GUIDs are created by taking system time into account. The
				risk for a key collision is therefore slightly higher, though still neglectable. The resulting GUIDs are
				already sorted after creation, increasing database performance. 
				</td>
			</tr>
			<tr>
				<td>Increment</td>
				<td><tt>PrimaryKeyType.Increment</tt></td>
				<td>
				Increments values locally. This is neither safe in clusters nor in applications with multiple clients.
				</td>
			</tr>
			<tr>
				<td>User Assigned</td>
				<td><tt>PrimaryKeyType.Assigned</tt></td>
				<td>
				The key has a business meaning and is not generated but must be assigned by the user before
				<tt>Create()</tt> or <tt>Update()</tt> is called.
				</td>
			</tr>
		</table>
		<p>
		Some strategies require more parameters, which can be specified by using the <tt>Params</tt> property.
		The parameters needed are specified as <tt>name=value</tt>-pairs separated by commas as shown in the
		following example:
		</p>
		
	<pre format="cs">
	private String id;
	
	[PrimaryKey(PrimaryKeyType.UuidHex, Params="format=D,seperator=-")]
	public String Id
	{
		get { return id; }
		set { id = value; }
	}</pre>
		
	</section>

	<section id="identity">
		<title>The Identity Problem</title>
		<p>
		Despite being the default generator, using <tt>IDENTITY</tt> keys is discouraged. The reason for this
		is an exception to the regular lifecycle when identity keys are used.
		</p>
		<p>
		When an entity is saved, a primary key must be assigned. However, the only possibility to determine a key
		using a database assigned identity value is inserting a row into a table. As a consequence, the entity
		is instantly saved to the database outside of any coordinated database flush. 
		</p>
		<p>
		This is not perceived in the code unless a <tt>SessionScope</tt> is used which is mandatory for lazy
		loading and a common pattern in web applications. Since the scope can be defined far away from the
		code that actually performs the call to <tt>Save()</tt>, this code behaves differently based on the
		context it is executed in. This is a maintenance nightmare which should be avoided by using other
		key generation strategies.
		
		Also <tt>IDENTITY</tt> generates an overhead of database calls, as described in 
		<a href="http://fabiomaulo.blogspot.com/2009/02/nh210-generators-behavior-explained.html">this blog article</a>.
		</p>
	</section>
	
	<section id="further">
	<title>Further Information</title>
	<p>
	Please refer to the Reference Manual's 
	<a href="../manual/attributedocs/index.html">Attributes</a> article for further information.
	</p>
	</section>
	
</section>

<section id="CompositePK">
	<title>Composite Primary Keys</title>

	<p>
	composite keys, also known as natural keys, consist of a set of columns that 
	define the identifier of a row. 
	</p>

	<note>
	<p>
	Composite keys are highly discouraged and should not be used unless there is no other alternative.
	</p>
	</note>

	<p>
	To use composite keys with ActiveRecord two things are necessary:
	
	<ol>
	<li>
	Creating a class to hold the properties and fields for 
	the columns that make up the key.
	<ul style="padding-top: 10px; padding-left: 13px;">
	<li style="list-style: square; list-style-type: square;">
	The class must be <tt>Serializable</tt></li>
	<li style="list-style: square; list-style-type: square;">
	<tt>Equals</tt> and <tt>GetHashCode</tt> must be overridden</li>
	</ul>
	</li>
	
	<li>
	Declaring the property on the <i>ActiveRecord type</i>, using the <tt>CompositeKeyAttribute</tt>.
	</li>
	</ol>
	</p>
	
	<p>
	This is shown for the following table script:
	</p>

	<pre format="tsql">
CREATE TABLE Users (
	[OrgID] [int] NOT NULL,
	[UserID] [int] NOT NULL,
	[Name] [varchar] (50) NULL,
	[Address] [varchar] (50) NULL,
	[City] [varchar] (50) NULL,
	[State] [varchar] (50) NULL
) ON [PRIMARY]
</pre>
	
	<p>
	The following is the definition of the composite key class <tt>ProductSupplierKey</tt>
	and next is the <i>ActiveRecord type</i>:
	</p>
	
	<pre format="cs">
using Castle.ActiveRecord;

[Serializable]
public class UserKey
{
	private int orgID;
	private int userID;
	
	[KeyProperty]
	public int OrgID
	{
		get { return orgID; }
		set { orgID = value; }
	}

	[KeyProperty]
	public int UserID
	{
		get { return userID; }
		set { userID = value; }
	}
	
	public override int GetHashCode()
	{
		return orgID ^ userID;
	}

	public override bool Equals(object obj)
	{
		if (this == obj)
		{
			return true;
		}
		UserKey key = obj as UserKey;
		if (key == null)
		{
			return false;
		}
		if (orgID != key.orgID || userID != key.userID)
		{
			return false;
		}
		return true;
	}
}

[ActiveRecord("Users")]
public class User : ActiveRecordBase
{
	private UserKey key;
	
	[CompositeKey]
	public UserKey Key
	{
		get { return key; }
		set { key = value; }
	}
}</pre>

	<warning>
		<p>
			There are <b>implications</b> on using composite keys discussed below. As was mentioned 
			above, Composite keys are
			discouraged. However, if they must be used, additional complexity in how the model is 
			mapped to the database must be addressed.
		</p>
	</warning>
	
	<section id="implications">
		<title>Implications of using composite keys</title>
		<p>
			An assigned identifier (like all CompositeKeys and assigned single PrimaryKeys) cannot
			be used to determine whether an instance is detached or transient - since its
			value is assigned by the application, it is <i>never</i> null. Therefore,
			one of the strategies below must be used or NHibernate will misbehave around the way it
			persists the instance to the database.
		</p>
		<p>
		
			To ensure that the data is persisted properly, two methods for managing persistence are 
			available:
		</p>
		<ol>
			<li>
				Using the <tt>VersionAttribute</tt> to set the <tt>UnsavedValue</tt>. Normally, 
				the <tt>UnsavedValue</tt> is used with the <tt>PrimaryKeyAttribute</tt>, where
				the <tt>UnsavedValue</tt> is checked by NHibernate to determine the state of the
				instance: if the field or property is equal to the <tt>UnsavedValue</tt>, then 
				the object has not yet been persisted. However, because the field or property marked
				with the <tt>CompositeKeyAttribute</tt> cannot have an <tt>UnsavedValue</tt> that 
				is understood by NHibernate, another field or property must be used - the one that
				was marked by the <tt>VersionAttribute</tt>. This allows the use of the 
				<tt>Save</tt> method. 
			</li>
			<li>
				<i>Not</i> using the <tt>Save</tt> method. <tt>Create</tt> and
				<tt>Update</tt> can be used to force NHibernate to correctly persisting the objects.
			</li>
		</ol>
		
		</section>
		
		<section id="relations">
			<title>Relations with composite keys</title>
			<p>
				Because a composite key is by nature multi-field, there are additional requirements
				when building the relations between objects that include these keys. The largest part
				of those requirements is that the <tt>HasMany</tt>, <tt>BelongsTo</tt> and
				<tt>HasAndBelongsToMany</tt> attributes will use different properties to determine the
				<tt>Column</tt>s, <tt>ColumnKey</tt>s and <tt>ColumnKeyRef</tt>s.
			</p>
			<p>
				To continue the example used above, the User class will be redefined and
				<tt>Org</tt> and <tt>Group</tt> classes added including their relationships.</p>
			<p>	
				First, some DDL is necessary to create the <tt>Org</tt> 
				and <tt>Group</tt> tables, as well as 
				the association table for the many-to-many 
				relationship between <tt>Users</tt> and <tt>Groups</tt>.
			</p>
			<pre format="tsql">
CREATE TABLE Orgs (
	[ID] [int] NOT NULL,
	[Name] [varchar] (50) NULL
) ON [PRIMARY]

CREATE TABLE Groups (
	[ID] [int] NOT NULL,
	[Name] [varchar] (50) NULL
) ON [PRIMARY]

CREATE TABLE UserGroups (
	[OrgID] [int] NOT NULL,
	[UserID] [int] NOT NULL,
	[GroupID] [int] NOT NULL
) ON [PRIMARY]</pre>
			<p>
				Next, the <tt>User</tt> class will be redefined, 
				adding the appropriate markup to maintain
				the mapping relationships.
			</p>
			<pre format="cs">
using Castle.ActiveRecord;

ActiveRecord("Users")]
public class User : ActiveRecordBase
{
	private UserKey key;
	private ISet groups;
	private Org org;

	public User()
	{
		groups = new HybridSet();
	}

	public User(UserKey userKey) : this()
	{
		key = userKey;
	}

	[CompositeKey]
	public UserKey Key
	{
		get { return key; }
		set { key = value; }
	}

	[HasAndBelongsToMany(typeof(Group),
		Table="UserGroups",
		ColumnRef="GroupID",
		CompositeKeyColumnKeys=new string[]{"OrgID","UserID"},
		Lazy=true,
		Cascade=ManyRelationCascadeEnum.SaveUpdate)
	public ISet Groups
	{
		get { return groups; }
	}

	[BelongsTo("OrgID", Insert=false, Update=false)
	public Org Org
	{
		get { return org; }
		set { org = value; }
	}
}</pre>
			<p>
				Note the <tt>CompositeKeyColumnKeys</tt> array, these are the fields that make up the
				foreign composite key in the association table.
			</p>
			<p>
				Another interesting item when dealing with composite keys is building a
				relationship using only a single field of the composite key as the foreign key in a
				traditional one-to-many or many-to-one relationship. The "one" side of that
				mapping in the definition of the "Org" property has set 
				<tt>Insert</tt>/<tt>Update</tt> to <tt>false</tt>. This is
				<b>not</b> optional. It prevents the other side of the relation from attempting to
				insert or update a portion of the composite key (in this case, the "OrgID" field).
			</p>
			<p>
				Next step is defining the other two classes, 
				illustrating the other side of the relationships.
			</p>
			<pre format="cs">
[ActiveRecord("Orgs")
public class Org : ActiveRecordBase
{
	private int id;
	private ISet users;

	public Org()
	{
		users = new HybridSet();
	}

	[PrimaryKey(PrimaryKeyType.Native)]
	public int ID
	{
		get { return id; }
		set { id = value; }
	}

	[HasMany(typeof(User), Lazy=true)
	public ISet Users
	{
		get { return users; }
	}
}

[ActiveRecord("Groups")]
public class Group : ActiveRecordBase
{
	private int id;
	private ISet users;

	public Group()
	{
		users = new HybridSet();
	}

	[PrimaryKey(PrimaryKeyType.Native)]
	public int ID
	{
		get { return id; }
		set { id = value; }
	}

	[HasAndBelongsToMany(typeof(User),
		Table="UserGroups",
		CompositeKeyColumnRefs=new string[]{"OrgID","UserID"},
		ColumnKey="GroupID",
		Lazy=true,
		Inverse=true,
		Cascade=ManyRelationCascadeEnum.SaveUpdate)
	public ISet Users
	{
		get { return users; }
	}
}</pre>

	<p>
		On the side of the relationship <b>without</b> the composite key, an array of
		column refs is used, while on the side of the relationship <b>with</b> the composite key,
		it is an array of column keys.
	</p>
	
	
	</section>
	
</section>

</body>
</document>
