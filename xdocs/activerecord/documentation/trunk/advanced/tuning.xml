<?xml version="1.0"?>
<document order="7">
  <properties>
    <title>Tuning</title>
  </properties>

  <body>

<intro>
<p>
This article explains some steps towards a better performance.
</p>
</intro>

<section id="lazyload">
	<title>Lazy load</title>
	
	<p>
	Enable lazy load for relations as described on the <a href="../usersguide/lazy.html">
	User's guide: Enabling lazy load</a>. Lazy loading can be defined at the class level as well, using <tt>[ActiveRecord(Lazy=true)]</tt>.
	</p>
	<p>
	 Marking a class as lazy means that you all its persistent properties must be virtual (so NHibernate is able to intercept and load the property when it is required) and all accesses (even inside the class) to properties must be done using the properties (and not the fields).
	</p>
	<note>
<p>
	Lazy loading is only possible when you are inside a scope!
</p>
</note>
	<p>
	Lazy loading is one of the more important tools in increasing the performance of an application, and like most performance related issues, it require testing in the context of the application to know what is the best solution for each scenario.
	</p>
	<!-- TODO: Ayende,
		Need to document default-lazy on the trunk!
	-->
</section>


<section id="relations">
	<title>Overused Relations</title>
	<p>
	If your code does intensive work on relations, consider replacing the operation by
	a <a href="../usersguide/hql.html">HQL query</a>. Databases are very optimized to 
	handle process on a  huge amount of data.
	</p>
	<p>
	Using HQL, you can specify the data that you want to load, saving database roundtrips. For instnace, here is how we load a post with all its comments:
	<pre forrmat="hql">
	from Post p join fetch p.Comments
	where p.Id = 1
	</pre>
	In almost all cases, it is better to ask the database for the data as expclictly as possible, rather than loading the data on demand. The HQL langauge is can bring a lot of power into your hands. Consult the <a href="http://www.hibernate.org/hib_docs/reference/en/html/queryhql.html">NHibernate documentation on HQL</a> for all the detials.
	</p>
</section>

<section id="eager-load">
	<title>Eager load</title>
	<p>
	TODO: Eager fetching.
	</p>
</section>
<section id="Profiling">
	<title>Profiling Active Record</title>

	<p>
	The easiest way to figure out what is going on with Active Record is to watch how it talks to the database. In a console application, all we need to do is to tell NHibernate that we would like it to show us the queries, by adding this to Active Record config section:
	<pre format="html">
	&lt;add key="hibernate.show_sql" value="true" &gt;
	</pre>
	</p>
	<p>
	However, in a web (or WinForms for that matter) scenario, that is not very helpful. For that, we need to redirect NHibernate's logging to a useful place. Let's start by simply logging all the queries to the trace (which we can show as part of the page). Add the following to your web.config file:
	<pre format="html">
	 &lt;configSections&gt;
		&lt;section name="log4net"  type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" /&gt;
	&lt;/configSections&gt;
	
	&lt;log4net&gt;
		&lt;appender name="trace" type="log4net.Appender.TraceAppender, log4net"&gt;
			&lt;layout type="log4net.Layout.PatternLayout,log4net"&gt;
				&lt;param name="ConversionPattern" value="%d [%t] %-5p %c [%x] &lt;%P{user}&gt; - %m%n" /&gt;
			&lt;/layout&gt;
		&lt;/appender&gt;
		
		&lt;appender name="NHibernate.SQL">
			&lt;appender-ref name="trace" /&gt;
		&lt;/appender&gt;
	&lt;/log4net&gt;
	</pre>
	</p>
	<p>
	Another very useful tool in this regard is SQL Server Profiler, which can show you the queries executed on the server in real time.
	</p>
</section>

<section id="sql">
	<title>Too many selects</title>

	<p>
	TODO: SELECT N+1 
	</p>
	
</section>

</body>
</document>
