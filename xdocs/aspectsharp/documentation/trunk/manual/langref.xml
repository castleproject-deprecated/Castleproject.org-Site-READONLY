<?xml version="1.0"?>
<document order="10">
  <properties>
    <title>Configuration Language Reference</title>
  </properties>

  <body>

<intro>

<p>Reference documentation of the Aspect Sharp's configuration language</p>
	
<p>The purpose of Aspect# language is to offer you a cleaner way to configure, describe and document your aspects configuration without have to rely on creepy xml syntax to do so.</p>

</intro>
 
<toc/>

<section id="basic">
<title>Basic definitions</title>

<p>
You must obey to a few rules to use the Aspect# language, and the first rule is that order matters. So your declarations must obey this sequence:

</p>

<pre>
 [Imports]
 
 [Global Interceptor map]
 
 [Global Mixin map]
 
 Aspects definitions
</pre>

</section>
		
<section id="imports">
<title>Imports</title>

<p>
The imports section helps you to keep a clean code and helps the language to resolve the types.
</p>

<pre>
 Import Namespace.Name [in AssemblyName]
</pre>

<tt>Examples:</tt>
	
<pre>
 Import System.Collections in System

 Import AspectSharp.Core
</pre>

</section>
		
<section id="interceptors">
<title>Global Interceptors</title>

<p>
In the case that you have an interceptor that is going to be used in more than one aspect - or even more than one pointcut, you can define it in an global interceptor section:
</p>

<pre>
 interceptors [ 
   "key" : InterceptorType ; 
   "key2" : InterceptorType2 
 ]
</pre>
	
<tt>Examples</tt>

<pre>
 interceptors [ 
   "logger" : DigitalGravity.Interceptors.Logger in DigitalGravity.XProject 
 ]


 Import DigitalGravity.Interceptors in DigitalGravity.XProject
 
 interceptors [ 
   "logger" : Logger 
 ]</pre>
	
	
<p>Once you've done it, you can refer to them in an aspect declaration by their keys:</p>

<pre>
 aspect Test for MyClass
 
   pointcut method(*)
     advice("key")
   end
 
   pointcut property(*)
     advice("key2")
   end
 
 end
</pre>
</section>
		
<section id="gmixins">
<title>Global Mixins</title>

<p>For the same reason there is also a mixin global section:</p>

<pre>
 mixins [ 
   "key" : MixinType ; 
   "key2" : MixinType2 
 ]
</pre>
	
<tt>Examples</tt>

<pre>
 mixins [ 
   "security" : DigitalGravity.Mixins.SecurityMixin in DigitalGravity.XProject 
 ]


 Import DigitalGravity.Mixins in DigitalGravity.XProject
 
 mixins [ 
   "security" : SecurityMixin
 ]
</pre>
	
<p>Once you've done it, you can refer to them in an aspect declaration by their keys:</p>

<pre>
 aspect Test for MyClass
 
   include("security")
 
 end
</pre>

</section>
		
<section id="aspects">
<title>Aspects</title>

<p>An aspect section defines which mixins and which pointcuts will be applied to a type or a set of types:</p>

<pre>
 aspect Name for Type 
   [include]
   [pointcuts]
 end
</pre>
	
<tt>Examples</tt>

<pre>
 aspect MyAspect for Customer
 end

 aspect MyAspect for [ My.Namespace.Classes excludes(Customer,Author) ]
 end

 aspect MyAspect for [ assignableFrom(Customer) ]
 end

 aspect MyAspect for [ customMatcher(MyAspectMatcher) ]
 end
</pre>
	
<p>When you invoke the AspectEngine.Wrap method on an instance, basically Aspect# will try to match the aspects for that particular instance. If more than one are matched, a new aspect is created from the union and will be used as the aspect definition. </p>

<p>If you need a more specific semantic to match aspects, you can provide your own using the customMatcher keyword (as the example above). Your class must implement the IClassMatcher interface and perform its logic returning true if the instance is eligible for that aspect. </p>

</section>
		
<section id="includes">
<title>Includes</title>

<p>
You use one or more include to add mixins to the resulting type in an aspect definition.
</p>
	
<tt>Examples</tt>

<pre>
 aspect MyAspect for Customer
   include DigitalGravity.Mixins.Security in DigitalGravity.XProject
   include System.Collections.ArrayList in System
 end
</pre>
</section>
 
<section id="pointcuts">
<title>Pointcuts</title>

<p>The purpose of pointcuts is to define an expression that must be true (matched) in order to introduce advices.</p>

<pre>
 pointcut [target][method signature]
   advice(type)
   advice("key")
 end
</pre>
	
<p>The possible targets are:</p>

<ul>
<li>method</li> 
<li>property </li>
<li>propertyread </li>
<li>propertywrite </li>
</ul>

<p>You can also combine them if you want, provided that they make sense</p>

<pre>
 pointcut method|property(*)
 end

 pointcut method|propertyread(*)
 end

 pointcut propertywrite(*)
 end
</pre>
	
<p>Using property|propertywrite for instance is meaningless, and you'll get an error.</p>

<p>The method signature can be simple as a (*) meaning everything, or (System.IList Create(int, *)) meaning methods named Create that returns System.IList and have at least the first argument of the type int. Please note that return types and argument types here are not resolved, so you have to use the full type name. </p>

<warning>
<p>Regular expressions are not fully supported. In fact, you can use only .* to match something in the rest of an name like (Str.* Create(int, string)) that will match Create methods with two arguments (the first an int and the second a String) and returning a type which the name starts with Str, like String, Strange, Stripissimo and so on.</p>
</warning>
	
<tt>Examples</tt>

<pre>
 // All read and write property named Name
 pointcut property(* Name)
 end

 // All read and write property named 
 // C***Name like CustomerName
 pointcut property(string C.*Name)
 end

 // The method Perform returning void with no arguments 
 pointcut method(void Perform)
 end

 // The method Perform with the first argument as String
 // and we don't care about the other arguments
 pointcut method(void Perform(string, *))
 end
</pre>
</section>
		
<section id="advices">
<title>Advices</title>

<p>Advices are the pieces of code that will be associated with a given joinpoint. Aspect# only supports MethodInterceptors advices. </p>

<p>Please note that we use lazy instantiation of interceptors and only one instance of an interceptor will exist per Wrap(). In other words, proxies will not share interceptors. </p>

<tt>Examples</tt>

<pre>
 aspect MyAspect for Customer
   pointcut method(*)
     advice(LogInvocationInterceptor)
   end
 end


 aspect MyAspect for Customer
   pointcut method(*)
     advice(Namespace.MyLogger in MyAssembly)
   end
 end
</pre>
</section>
		
</body>
</document>
