<?xml version="1.0"?>
<document order="30">
  <properties>
    <title>Aspect Engine</title>
  </properties>

  <body>

<intro>

<p>The AspectEngine is the entry point to add AOP capabilities to your classes. Usually there is no point in just constructing an AspectEngine and start using it. You need one of the Builders to proper construct an AspectEngine with a configuration that depicts your intentions. For more information about builder, check the <a href="TODO">Builder Reference</a>.</p>

<warning>
<p>
This is document is a WORK IN PROGRESS
</p>
</warning>

</intro>


<section id="aspectconfiguration">
<title>The AspectEngine.Wrap method</title>

<p>Once you have your proper AspectEngine instance, use the Wrap method with a object instance to start all the magic. From now on let's call this instance the invocation target.</p>

<pre format="cs">
 using System.Collections;
 
 AspectEngine engine = // ...
 IList list = engine.Wrap( new ArrayList() ) as IList;
</pre>

<p>
Here is what happens in a nutshell:

<ol>
	<li>The engine will extract the inner type of instance</li>
	<li>This inner type is compared with the aspect definitions in the configuration
		<ul>
		<li>If no match is found, the very same instance is returned</li>
		<li>If a match is found, the instance is wrapped with a proxy and the proxy is returned</li>
		</ul>
	</li>
</ol>
</p>
	
<p>You must note that the instance you've passed in the Wrap's argument is used by the proxy, so now you have a totally different instance to work with. See the caveats section to see it can be a problem for some cases.</p>

<p>The returned proxy is guaranteed to:
<ul>
<li>Extend your type</li>
<li>Override all virtual methods in your type a dispatch to the invocation target</li>
<li>Implement all mixins interfaces if any</li>
<li>Create all mixins instances that your aspect declare</li>
<li>Dispatch invocations to the mixins to the proper mixin instance</li>
</ul>
</p>

<p>Please note that for performance reasons we don't check for collisions in the types implemented. So, if your type exposes a Name property and one of the mixin have this same property on its interface you'll get a really nasty error.</p>

<p>Your mixins must have a default constructor or the engine won't be able to create the mixins instances.</p>

</section>

<section id="aspectconfiguration">
<title>The AspectEngine.WrapInterface method</title>

<p>This method, available since Alpha 2.0.0.4, allows you to specify the target type to be matched and the invocation target instance.</p>

<pre format="cs">
 using System.Collections;
 
 AspectEngine engine = // ...
 IList list = engine.WrapInterface( typeof( IList ), new ArrayList() ) as IList;
</pre>

<p>Despite the fact that you may have the same result, Aspect# will chose a different path when generating the proxy for you. In this case you don't have to be afraid of non-virtual methods not being overrided, thus this is a safer strategy if you're dealing with type that you don't have control.</p>

<p>Also, if you have an aspect definition for a interface, instead of a concrete type, you may be forced to use the WrapInterface instead.</p>
	
</section>

</body>
</document>
