<?xml version="1.0"?>
<document order="30">
  <properties>
    <title>Registering components through code</title>
  </properties>

  <body>

<intro>

<p>
To get things moving, we need to create a Windsor Container
instance and start registering components into it. This allows
the container to act on the components. Let's start by registering
our <tt>Form1</tt> class on the container.
</p>

<pre format="cs">
using Castle.Windsor;

public class App
{
	public static void Main()
	{
		IWindsorContainer container = new WindsorContainer();
		
		// Register the component
		container.AddComponent("form.component", typeof(Form1));
		
		// Request the component to use it
		Form1 form = (Form1) container[typeof(Form1)];
		
		// Use the component
		Application.Run(form);
		
		// Release it
		container.Release(form);
	}
}</pre>

<p>
You can run the application and certify that it works as expected.
</p>

<p>
Now let's create a few mock services to mimic a real application.
For example, let's create a <tt>HttpServiceWatcher</tt>. 
In the real world this watcher would make requests from time to time
to a Http server to make sure it is running.
</p>

<p>
What if the server is not running? 
Well, it should definitely do something. Should it send an email to someone?
Should it start an alarm? Even if it needs to do these two things, where should
this code go?
</p>

<p>
If your answer is, let's code <tt>HttpServiceWatcher</tt>
in a way that it is capable of sending emails and sound alarms, then you should
read more about Separation of Concerns. As the name imples, the <tt>HttpServiceWatcher</tt>
should <b>only watch the http service status</b>. The logic to send emails
or sound alarms can be put on different implementation of an <tt>IFailureNotifier</tt>
service. 
</p>

<p>
Our service can look like the following:
</p>

<pre format="cs">
namespace GettingStartedPart1
{
	using System;

	public class HttpServiceWatcher
	{
		public void StartWatching()
		{
			
		}
		
		public void StopWatching()
		{
			
		}
	}
}
</pre>

<p>
We can then create the <tt>IFailureNotifier</tt> and a few implementations like
<tt>EmailFailureNotifier</tt> and <tt>AlarmFailureNotifier</tt>:
</p>

<pre format="cs">
namespace GettingStartedPart1
{
	using System;

	public interface IFailureNotifier
	{
		void Notify();
	}
}</pre>

<pre format="cs">
namespace GettingStartedPart1
{
	using System;

	public class EmailFailureNotifier : IFailureNotifier
	{
		public void Notify()
		{
			// Send email to admins
		}
	}
}</pre>

<pre format="cs">
namespace GettingStartedPart1
{
	using System;

	public class AlarmFailureNotifier : IFailureNotifier
	{
		public void Notify()
		{
			// Turn on alarm
		}
	}
}</pre>

<p>
But how or <tt>HttpServiceWatcher</tt> can gain access to a notifier?
We can use a constructor or a property, depends on the semantics. Ask yourself these
questions:
<ul>
<li>Does it make sense to have a watcher without a notifier?</li>
<li>If a failure is detected, and no notifier exists, what should the watcher do?</li>
</ul>
</p>

<p>
IMHO the watcher needs a notifier (<tt>HttpServiceWatcher</tt> <b>depends on</b> 
an <tt>IFailureNotifier</tt> implementation). Let's make this decision clear to
the container:
</p>

<pre format="cs">
public class HttpServiceWatcher
{
	private IFailureNotifier notifier;
	
	public HttpServiceWatcher(IFailureNotifier notifier)
	{
		this.notifier = notifier;
	}

	public void StartWatching()
	{
		// should start a thread to ping the service
		
		// if (pingresult == Failed)
		// {
		
		notifier.Notify();
		
		// }
	}
	
	public void StopWatching()
	{
		// stop thread
	}
}</pre>

<p>
Now the Windsor Container (in fact the MicroKernel) knows that
in order to create an <tt>HttpServiceWatcher</tt> instance, it 
needs an implementation of <tt>IFailureNotifier</tt> to supply.
</p>

<p>Let's change our <tt>App</tt> class to configure the components</p>:

<pre format="cs">
public static void Main()
{
	IWindsorContainer container = new WindsorContainer();
	
	// Register the components
	container.AddComponent("httpservicewatcher", typeof(HttpServiceWatcher));
	container.AddComponent("email.notifier", typeof(IFailureNotifier), typeof(EmailFailureNotifier));
	container.AddComponent("alarm.notifier", typeof(IFailureNotifier), typeof(AlarmFailureNotifier));
	container.AddComponent("form.component", typeof(Form1));
	
	// Request the component to use it
	Form1 form = (Form1) container[typeof(Form1)];

	...
</pre>

<p>
We should also make the <tt>Form1</tt> request the <tt>HttpServiceWatcher</tt>.
Now there is a trick here: if we change the constructor generated by 
Visual Studio designer, making a non-parameterless constructor, the 
designer will complain. So let's just create another constructor:
</p>


<pre format="cs">
public class Form1 : System.Windows.Forms.Form
{
	private readonly HttpServiceWatcher serviceWatcher;
	private System.ComponentModel.Container components = null;

	public Form1()
	{
		InitializeComponent();
	}
	
	public Form1(HttpServiceWatcher serviceWatcher) : this()
	{
		this.serviceWatcher = serviceWatcher;
	}

	...
</pre>

<p>
Now you are invited to run the application, debug it and see how the
"wiring" process happens. Add two buttons to the form so you can
call <tt>serviceWatcher.StartWatching()</tt> and <tt>serviceWatcher.StopWatching()</tt>.
</p>

<p>
Proceed with <a href="config.html">Using the configuration file</a>.
</p>

</intro>

</body>
</document>
