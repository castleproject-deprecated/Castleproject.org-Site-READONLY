<?xml version="1.0"?>
<document order="7">
  <properties>
    <title>Rescues</title>
  </properties>

  <body>

<intro>
	<p>
	A rescue is an association of a special view that will only be rendered
	if an exception happens. The view file must be present in a <tt>rescue</tt>
	folder directly under your views folder. 
	</p>

	<p>
	A rescue can be associated with a controller or per action. You can also
	bound a rescue with an exception. If the action throws an exception (the action
	cannot swallon the exception), MonoRail will match the rescue definition that 
	is closely related to the exception type and use the specified view.
	</p>

	<p>
	To create an association you must use the <tt>RescueAttribute</tt>. For example:
	</p>
	
	<pre format="cs">
using Castle.MonoRail.Framework;

[Rescue("dberror", typeof(System.Data.SqlException))]
public class ProductController : Controller
{
	[Rescue("commonerror")]
	public void Index()
	{
		throw new System.Data.SqlException("fake error");
	}

	[Rescue("dumbprogrammer", typeof(DivideByZeroException))]
	public void List()
	{
		int val = 0;
		int x = 10 / val;
	}

	public void Search()
	{
	}
}</pre>

<p>
The usage of the <tt>RescueAttribute</tt> in the example above
define the following rules:
<ul>
<li>If any action throws a <tt>SqlException</tt>, the view <tt>view/rescues/dberror</tt> will be selected
</li>
<li>If the action <tt>Index</tt> throws any kind of exception 
(including <tt>SqlException</tt>), the view 
<tt>view/rescues/commonerror</tt> will be selected. 
This overrides the definition in the controller level.
</li>
<li>
If the action <tt>List</tt> throws a <tt>DivideByZeroException</tt>, the 
view <tt>view/rescues/dumbprogrammer</tt> will be selected. 
</li>
</ul>
</p>

<p>
Whenever an exception happens, the MonoRail context (which is per request)
will populate the property <tt>LastException</tt> so your view can show 
the exception details.
</p>

</intro>

</body>
</document>
