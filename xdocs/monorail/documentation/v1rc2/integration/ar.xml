<?xml version="1.0"?>
<document order="10">
  <properties>
    <title>ActiveRecord Integration</title>
  </properties>

  <body>

<intro>

<p>
If you are using ActiveRecord you 
may consider using the integration we developed fo it. 
In order to do so, first of all, add a reference to the following assembly:
</p>

<p>
<ul>
<li> Castle.MonoRail.ActiveRecordSupport </li>
</ul>
</p>

</intro>

<section id="ARSmartDispatcherController">
	<title>ARSmartDispatcherController</title>

<p>
What we are about to discuss only works 
if you are using <tt>ARSmartDispatcherController</tt> 
instead of <tt>SmartDispatcherController</tt>. 
The <tt>ARSmartDispatcherController</tt> offers 
a <tt>CustomBindObject</tt> method that is ActiveRecord-aware.
</p>

</section>

<section id="ARDataBindAttribute">
	<title>ARDataBindAttribute and ARDataBinder class</title>

<p>
So imagine that you are creating a CRUD page for a 
<tt>Customer</tt> object. Creation is really simple, 
and the <tt>DataBindAttribute</tt> attribute is enough:
</p>

<pre format="cs">
public class CustomerController : ARSmartDispatcherController 
{
    public void Index()
    {
    }

    public void New()
    { 
    }

    public void Create([DataBind("customer")] Customer customer)
    { 
        try
        {
            customer.Create();

            RedirectToAction("index");
        }
        catch(Exception ex)
        {
            Flash["error"] = ex.Message;

            RedirectToAction("new", Request.Form);
        }
    }
}</pre>

<p>
Now editing is trick. You must load 
the <tt>Customer</tt>, and populate the 
changes with the form data. Enters <tt>ARDataBindAttribute</tt>:
</p>

<pre format="cs">
public class CustomerController : ARSmartDispatcherController 
{
    ...

    public void Edit(int id)
    { 
        PropertyBag.Add("customer", Customer.Find(id));
    }

    public void Update([ARDataBind("customer", AutoLoad=AutoLoadBehavior.Always)] Customer customer)
    { 
        try
        {
            customer.Update();

            RedirectToAction("index");
        }
        catch(Exception ex)
        {
            Flash["error"] = ex.Message;

            RedirectToAction("edit", Request.Form);
        }
    }
}</pre>

<p>
The <tt>ARDataBindAttribute</tt> extends the <tt>DataBindAttribute</tt> 
so the <tt>Exclude</tt> and <tt>Allow</tt> properties are still there.
</p>

<p>
However, as you can see, we used <tt>AutoLoad=AutoLoadBehavior.Always</tt>. 
This tells the binder to collect the primary key value for 
the customer and load it, then populate the object. 
So all you have to do next is to invoke <tt>Save</tt> or <tt>Update</tt> method.
</p>

</section>

<section id="AutoLoad">
	<title>The AutoLoad property</title>

	<p>
	It is very important that you know what the AutoLoad property means
	and the behavior it governs.
	</p>

	<p>
	<table class="commontable">
	<tr>
		<th>Enum field</th>
		<th>Description</th>
	</tr>
	<tr>
		<td><tt>Never</tt></td>
		<td> Means that no autoload should be performed on the target
		type or on nested types.</td>
	</tr>
	<tr>
		<td><tt>Always</tt></td>
		<td> Means that autoload should be used for the target type
		and the nested types (if present). This demands that
		the primary key be present on the http request for the root type and nested.</td>
	</tr>
	<tr>
		<td><tt>OnlyNested</tt></td>
		<td> Does not load the root type, but loads nested types
		if the primary key is present. If not present, sets <c>null</c> on nested type.
		This is useful for insertions.</td>
	</tr>
	<tr>
		<td><tt>NewInstanceIfInvalidKey</tt></td>
		<td> Means that we should autoload, but if the key is 
		invalid, like <c>null</c>, 0 or an empty string, then just
		create a new instance of the target type.</td>
	</tr>
	<tr>
		<td><tt>NullIfInvalidKey</tt></td>
		<td> Means that we should autoload, but if the key is 
		invalid, like <c>null</c>, 0 or an empty string, then just
		set <c>null</c> on the nested type.</td>
	</tr>
	</table>
	</p>
	
</section>

<section id="ARFetch">
	<title>ARFetchAttribute</title>

<p>
The <tt>ARFetchAttribute</tt> is a simpler version of <tt>ARDataBinder</tt>. 
It is in charge of loading the instance from the database and nothing more. 
</p>

<pre format="cs">
public class CustomerController : ARSmartDispatcherController 
{
    ...

    public void SetPassword([ARFetch("customer.id")] Customer customer, String newPassword)
    { 
        try
        {
            customer.Password = newPassword;
            customer.Save();

            RedirectToAction("index");
        }
        catch(Exception ex)
        {
            Flash["error"] = ex.Message;

            RedirectToAction("changepassword", Request.Form);
        }
    }
}</pre>

<p>
The optional parameter passed to <tt>ARFetch</tt> 
tells it which form field has the primary key value. 
If you don't specify it, it will use the parameter 
name (for the example above it would be <tt>customer</tt>)
</p>

<p>
You can also specify <tt>Required=true</tt> which will 
force it to throw an exception if the record is not found:
</p>

<pre format="cs">
public class CustomerController : ARSmartDispatcherController 
{
    ...

    public void SetPassword([ARFetch("customer.id", Required=true)] Customer customer, String newPassword)
    { 
        ...
    }
}</pre>

<p>
And <tt>Create=true</tt>, which will create a 
new object if the primary key form field is empty:
</p>

<pre format="cs">
public class CustomerController : ARSmartDispatcherController 
{
    ...

    public void CreateOrModifyCustomer([ARFetch("customer.id", Create=true)] Customer customer, String name, ...)
    { 
        customer.Name = name;
        customer.Save();
    }
}</pre>

</section>

</body>
</document>
